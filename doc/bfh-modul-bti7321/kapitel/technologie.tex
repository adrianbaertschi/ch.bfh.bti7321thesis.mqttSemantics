\chapter{Technologie}
\label{chap:technologie}

\section{MQTT}

\textit{Die folgende Einführung des MQTT Protokolls wurde aus der dem Ergebnis des BFH Modul BTI7302 (Projekt 2) von Adrian Bärtschi übernommen.}

MQTT (Message Queue Telemetry Transport) ist ein Netzwerkprotokoll, das sich dank einfachem und leichtgewichtigen Design sehr gut für Geräte mit stark eingeschränkten Ressourcen und Netzwerke mit geringer Bandbreite eignet. 
\\
Die erste Version von MQTT wurde 1999 von Dr. Andy Stanford-Clark (IBM) und Arlen Nipper (Arcom) beschrieben und entwickelt. Inzwischen ist MQTT in der Version 3.1.1 verfügbar  \cite{mqttSpez} und wird von OASIS Konsortium (\url{https://www.oasis-open.org}) standardisiert.

Im OSI Modell ist MQTT auf dem Application Layer eingeordnet, basierend auf dem TCP Stack.

\begin{figure}[H]
	\centering
		\includegraphics[width=0.6\textwidth]{diag/osi_mqtt.png}
	\caption{\label{fig:mqttosi}MQTT im (vereinfachten) OSI Stack}
\end{figure}

\subsection{Publish/Subscribe}
MQTT funktioniert nach dem Publish/Subscribe Pattern. Im Gegensatz zum klassichen Client/Server Prinzip registrieren sich die Clients (Subscriber) bei einem Broker für bestimmte Bereiche (Topics), zu denen sie Nachrichten erhalten möchten.
\\ \\

\begin{figure}[H]
	\centering
		\includegraphics[width=0.8\textwidth]{diag/pub_sub.png}
	\caption{\label{fig:pub_sub}Publish/Subscribe Prinzip}
\end{figure}


\par
Ein Publisher, (z. Bsp. ein Sensor) sendet seine Nachrichten an den Broker. Alle Subscriber, die sich für das entsprechende Topic eingeschrieben haben, erhalten die Nachricht vom Broker. 
\\ \\
Diese Entkopplung der Teilnemhner bringt diverse Vorteile mit sich:

\begin{itemize}
\item Publisher und Subscriber müssen sich gegenseitig nicht kennen
\item Clients können sich beliebig an- und abmelden
\item Beim Ausfall eines Teilnehmers sind die anderen nicht blockiert
\end{itemize}

\subsection{Topics}
Jede Nachricht wird an ein bestimmtes Topic gesendet. Grundsätzlich kann jeder Client zu jedem Topic des Brokers Nachristen veröffentlichen. Die Topics sind hierarchisch aufgebaut, die Ebenen werden durch einen Slash (/) getrennt.\\
Zum Beispiel könnte ein Thermometer seine Temperatur im Topic \texttt{house/livingroom/temperature} veröffentlichen.\\ \\
Um die Nachrichten zu erhalten, muss sich nun ein anderer Client für dieses Topic einschreiben. Dabei können die Wildcards \texttt{+} und \texttt{\#} verwendet werden.\\
Das \texttt{+} Symbol steht für eine Ebene in der Topic Hierarchie.\\
Beispiel: \texttt{house/+/temperature} steht für die Temperaturmeldungen aller Räume des Hauses .

\begin{itemize}
	\item \texttt{house/livingroom/temperature}
    \item \texttt{house/kitchen/temperature}
    \item \texttt{house/bedroom/temperature}
    \item \texttt{...}
\end{itemize}

Mit \texttt{\#} werden alle Topics des Unterbaums abonniert.
Beispiel: Wenn ein Client das Topic \texttt{house/\#} abonniert, erhält dieser alle Meldungen des Hauses.

\begin{itemize}
	\item \texttt{house/bedroom/temperature}
    \item \texttt{house/door/status}
    \item \texttt{...}
\end{itemize}

\subsection{Messages}
Messages in MQTT sind sehr einfach aufgebaut. Eine Message hat folgende Attribute:\\

\begin{table}[h!]
\centering
\begin{tabular}{ |l|l| }
	\hline
	Attribut & Beschreibung \\ 
	\hline
	Payload    	& Beliebige Daten im Binärformat. Maximal 256 MB     \\
	QoS    		& Quality of Service 0, 1 oder 2. Details in Kapitel \ref{qos}    \\ 
	Retained    & Flag, true oder false, Details in Kapitel \ref{retained}     \\ 
	\hline
\end{tabular}
\caption{Aufbau einer MQTT Message}
\end{table}


\subsection{Quality of Service} \label{qos}
MQTT bietet drei verschiedene QoS Einstellungen für das versenden von Nachrichten.
\begin{itemize}
\item 0: Die Nachricht wird einmal versendet, es gibt keine Bestätigung des Empfängers.
\item 1: (Standard) Die Nachricht wird mindestens einmal beim Empfänger ankommen. Es wird so lange versucht zu senden, bis eine Bestätigung erhalten wurde.
\item 2: Mit ein Handhshake Mechanismus wird sichergestellt, dass die Nachricht genau einmal beim Empfänger angekommen ist.
\end{itemize}

Je höher die QoS Einstellung, desto mehr Resourcen werden beim versenden benötigt und es desto mehr Daten werden über das Netzwerk gesendet.

\subsection{Retaines Messages} \label{retained}
Bei einer MQTT Message kann das Retained Flag gesetzt werden. Damit wird pro Topic die letzte Nachricht auf dem Broker gespeichert. Verbindet sich ein neuer Client und abonniert das Topic, erhält er die retained Message sofort. Dies kann nützlich sien bei Anwendungen mit Topics, die sehr lange Pausen zwischen den Meldungen haben.

\subsection{Last Will}
Jeder Client, der sich zum Broker vebindet, kann eine ''Last Will'' Message angeben. Diese Meldung wird an das gewünschte Topic gesendet, sobald die Verbindung beendet wird.

\pagebreak

\subsection{Implementationen}
Inzwischen sind zahlreiche Implementationen von sowohl MQTT Brokern, als auch Client Libraries verfügbar.

\paragraph{Broker}

\begin{center}
\begin{tabular}{ | m{5em} | m{25em}| m{12em} | }
 \hline
 Name & Beschreibung & URL \\
 \hline
 Mosquitto  & Leichtgewichtiger Open Source Broker geschrieben in C. Zurzeit de-facto standard MQTT Broker. & \url{http://mosquitto.org/}  \\
 \hline
 ActiveMQ Apollo   & OSS Message Broker, untersützt neben MQTT noch andere Protokolle. Konfiguration und Administration über Web GUI. & \url{http://activemq.apache.org/apollo/}  \\
  \hline
 Moquette  & OSS Broker Implementation in Java. Kann auch als Library in eigene Projekte eingebunden werden. & \url{https://github.com/andsel/moquette}  \\
 \hline
  HiveMQ  & Proprietärer MQTT Broker, ausgerichtet für Enterprise Anwendungen.  & \url{http://www.hivemq.com/}  \\
 \hline
  Mosca  & MQTT Broker für die NodeJS Platform. Kann als Standalone oder Embedded Broker verwendet werden.  & \url{http://www.mosca.io/}  \\
\hline

\end{tabular}
\end{center}



\paragraph{Client Libraries}

Das Eclipse Projekt Paho \cite{paho} stellt Client Libraries für C, Java, Android, Python,
 Javascript, C/C++ embedded und .Net / WinRT zur verfügung. Die Java Library sich als stabil und gut dokumentiert erwiesen.

Eine Lister mit weiteren Client Libraries ist im MQTT Wiki \cite{clientLibs} zu finden.



\section{Bestehende Konzepte}
Die verschiedenen Hersteller von MQTT Anwendungen entwickeln jeweils ihre eigenen Ansätze, um die Daten zu strukturieren. 


\subsection{IBM Internet of Things Foundation}

IBM hat unter dem Brand `IBM IoT Foundation' \cite{ibmIotF:home} einen Dienst entwickelt, mit dem vernetzte Geräte verwaltet werden können. Als Kommunikationsprotokoll wird MQTT eingesetzt. Die Plattform verwendet folgende konzeptionelle Ideen:
\begin{itemize}
    \item Organizations: Eindeutige Identifikation der Kunden der Plattform
	\item Devices: Beliebiges vernetztes Gerät. Versendet Events und reagiert auf Commands.
	\item Applications: Anwendung, welche mit den Daten der Devices interagiert.
	\item Events: Daten, welche von den Devices an die Plattform gesendet werden
	\item Commands: Applications können mittels Commands mit den Devices kommunizieren.
\end{itemize}

\textbf{Events} \\
Events müssen an ein definiertes Topic nach folgendem Schema gesendet werden: \\
\code{iot-2/evt/<event\_id>/fmt/<format\_string>}

Beispiel: \code{iot-2/evt/temperature\_outdoor/fmt/json}

Eine Anwendung, welche Events empfangen möchte, muss sich auf ein Topic in der Form \\
\code{iot-2/type/<device\_type>/id/<device\_id>/evt/<event\_id>/fmt/<format\_string>} registrieren.
Die Teile \code{device\_type}, \code{device\_id}, \code{event\_id} und \code{format\_string} des Topics können auch mit dem Wildcard Charakter '\code{+}' ersetzt werden, um jeweils alle Events der Komponenten zu erhalten. 

Beispiel: \code{iot-2/type/temp/id/+/evt/temperature\_outdoor/fmt/+}

\textbf{Commands} \\
Um einen Command zu erzeugen, sendet eine Anwendung eine MQTT Message mit Topic gemäss folgenden Schema:
\code{iot-2/type/<device\_type>/id/<device\_id>/cmd/<command\_id>/fmt/<format\_string>}

Beispiel: \code{iot-2/type/temp/id/sensor1/cmd/setInterval/fmt/json}

Das Device \code{sensor1} würde damit eine Message auf Topic \code{iot-2/cmd/setInterval/fmt/json} erhalten.


\textbf{Payload Format} \\
Grundsätzlich unterstützt IBM IoT Foundation ein beliebiges Payload Format. Es wird jedoch empfohlem, JSON zu verwenden. Um alle Funktionen der Platform nutzen zu können, müssen die JSON Dokumente zusätzlich nach den Vorgaben \cite{ibmIotF:payload} von IBM strukturiert sein.

\begin{listing}[H]
\begin{minted}[frame=single,
               framesep=3mm,
               linenos=false,
               xleftmargin=21pt,
               tabsize=4]{json}
{
  "d": {
    "host": "IBM700-R9E683D",
    "mem": 54.9,
    "network": {
      "up": 1.22,
      "down": 0.55
    },
    "cpu": 1.3,
  }
}
\end{minted}
\caption{JSON Beispiel im IBM IoTF Payload Format}
\end{listing}



\subsection{Tinkerforge MQTT Proxy}

Tinkerforge hat ein modulares System von Sensoren und Aktoren (so gennate Bricklets) entwickelt, die u. A. für Prototyping und in der Ausbildung (auch an der BFH) eingesetzt werden. Um die Mudule zu steuern, wird klassischerweise das bereitstellete SDK in der gewünschten Programmiersprache verwendet. 
Tinkerforge ausserdem eine Anwendung entwickelt und die Bausteine per MQTT ansprechen zu können \cite{tinkerf:mqtt}.

\textbf{Topics} \\
Die Tinkerforge Devices senden ihre Daten an ein MQTT Topic nach Schema \\ \code{tinkerforge/<prefix>/<uid>/<suffix>}.

Ein Temperatur Bricklet mit \acrfull{uid} \code{xf2} würde also den gemessenen Wert an das Topic \\
\code{tinkerforge/bricklet/temperature/xf2/temperature} senden.

Die Bricklets reagieren auf Messages die an ein passendes Topic mit Siffix \code{/set} gesendet werden. Sollen beispielsweise die LEDs des Dualbutton Bricklets mit UID \code{mxg} eingeschaltet werden, muss eine Message an das Topic \code{tinkerforge/bricklet/dual\_button/mxg/led\_state/set} gesendet werden mit folgendem Payload:

\begin{listing}[H]
\begin{minted}[frame=single,
               framesep=3mm,
               linenos=false,
               xleftmargin=21pt,
               tabsize=4]{json}
{
    "led_l": 2,
    "led_r": 2
}
\end{minted}
\caption{JSON Beispiel Tinkerforge Format}
\end{listing}



\textbf{Payload Format} \\
Die Tinkerforge MQTT Komponente verwendet JSON als Datenformat für die Messages. Jede Message, die von einem Bricklet gesendet wird, enthält unter dem Key \code{\_timestamp} den Zeitpunkt der Erzeugung als UNIX Timestamp.

\begin{listing}[H]
\begin{minted}[frame=single,
               framesep=3mm,
               linenos=false,
               xleftmargin=21pt,
               tabsize=4]{json}
{
  "_timestamp": 1440083842.785104,
  "temperature": 2343
}
\end{minted}
\caption{JSON Beispiel Tinkerforge Format}
\end{listing}


Die Beschreibung, unter welchen Topics Daten publiziert werden und wie die Bricklets angesprochen werden können, ist in der Dokumentation von Tinkerforge \cite{tinkerf:mqtt} beschrieben.


\section{Datenformate}

In diesem Kapitel werden verschiedene Datenformate kurz beschrieben, welche für die Beschreibung der Devices in Frage kommen könnten. Grundsätzlich muss zwischen textbasierten und binären Formaten unterschieden werden.

Textbasierte Formate bieten den Vorteil, dass sie von Menschen ohne weitere Hilfsmittel gelesen und meistens auch interpretiert werden können. Die textuellen Formate haben jedoch Schwächen, mit binären Daten (Bilder, Video, Audio etc.) umzugehen. Zwar ist es möglich, die binären Daten in ein textbasiertes Format zu integrieren (beispielsweise mittels Kovertierung zu Base64), dies führt aber zur Aufblähung der Datenmenge.

Binäre Formaten haben den Vorteil, dass die Daten dichter codiert wrden können, somit werden die Dateien meistens kleiner als bei textbasierten Formaten. Der grosse Nachteil ist, dass man für die Interpretation von binären Daten auf eine Beschreibung (in Form eines Schemas) angewiesen ist.

TODO: Glossar Einträge

\textbf{JSON} \\
JSON ist ein textbasiertes Datenformat, welches Key-Value Paare für die Strukturierung nutzt. Dank dem einfachen Aufbau ist es sehr weit verbreitet und Libraries sind für alle populären Platformen verfügbar.

\begin{listing}[H]
\begin{minted}[frame=single,
               framesep=3mm,
               linenos=false,
               xleftmargin=21pt,
               tabsize=4]{json}
{
  "firstName": "Max",
  "lastName": "Muster",
  "age": 25,
  "address": {
    "street": "Bundeshaus",
    "plz": "3000",
    "city": "Bern"
  }
}

\end{minted}
\caption{JSON Beispiel, (148 byte)}
\end{listing}


\textbf{YAML} \\ 
YAML ist dem JSON Format sehr ähnlich, ist aber stärker auf Lesbarkeit ausgerichtet. Für die Strukturierung der Daten kann die kompakte schreibweise mit Leerzeichen verwendet werden. 
YAML ist ein Superset von JSON, das bedeuted jedes gültige JSON Dokument ist auch ein gültiges YAML Dokument.

\begin{listing}[H]
\begin{minted}[frame=single,
               framesep=3mm,
               linenos=false,
               xleftmargin=21pt,
               tabsize=4]{yaml}
---
firstName: Max
lastName: Muster
age: 25
address: 
  street: Bundeshaus
  postalCode: 3000
  city: Bern


\end{minted}
\caption{YAML Beispiel (107 byte)}
\end{listing}

\textbf{XML} \\
Mit XML werden die Informationen in hierarchische Elemente (Tags) verschachtelt, welche mit Attributen versehen werden können. XML Dokumente werden dadurch rasch sehr gross und haben viel redundaten Daten. Häufig werden XML Schemas eingesetzt, um di

\begin{listing}[H]
\begin{minted}[frame=single,
               framesep=3mm,
               linenos=false,
               xleftmargin=21pt,
               tabsize=4]{xml}
<person>
  <firstName>Max</firstName>
  <lastName>Muster</lastName>
  <age>25</age>
  <address>
    <street>Bundeshaus</streetAddress>
    <plz>3000</plz>
    <city>Bern</city>
  </address>
</person>


\end{minted}
\caption{XML Beispiel (200 byte)}
\end{listing}



\textbf{Protocol Buffers}
Protocul Buffer ist ein Mechanismus zur Serialisierung von Daten. Der Entwickler muss ein Schema seiner Datenstruktueren erstellen (.proto Datei).

\begin{listing}[H]
\begin{minted}[frame=single,
               framesep=3mm,
               linenos=false,
               xleftmargin=21pt,
               tabsize=4]{text}

message Person {
  required string firstName = 1;
  required string lastName = 2;
  required int32 age = 3;

  message Address {
    required string street = 1;
    required string plz = 2;
    required string city = 3;
  }
  
  required Address address = 4;

}

\end{minted}
\caption{Protocol Buffer (v2) Schema Beispiel}
\end{listing}


\begin{listing}[H]
\begin{minted}[frame=single,
               framesep=3mm,
               linenos=false,
               xleftmargin=21pt,
               tabsize=4]{text}
               
00000000  0a 03 4d 61 78 12 06 4d  75 73 74 65 72 18 19 22  |..Max..Muster.."|
00000010  18 0a 0a 42 75 6e 64 65  73 68 61 75 73 12 04 33  |...Bundeshaus..3|
00000020  30 30 30 1a 04 42 65 72  6e                       |000..Bern|
00000029

\end{minted}
\caption{Beispiel Protocol Buffer Daten (Output hexdump, 41 Bytes)}
\end{listing}


Anschliessend werden mit den bereitgestellten Tools (Protocol Buffer Combiler), Klassen für die Objekte der gewünschten Sprache zu generiert. Mit diesen Klassen können nun Daten in ein sehr kompaktes binäres Format Codiert und Decosiert werden.


\textbf{DFDL}


\subsection{Vergleich}

Lesbarkeit, Filegrösse, Unterstütze Platformen/Libraries, Komplexität/Lernkurve

\subsection{Entscheid}





\section{Konzept aus der nicht-IoT Welt}
SOAP-WSDL, REST, etc.
HATEOAS
